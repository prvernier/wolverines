y <- select(x, unlist(input$factors)) %>%
st_intersection(data$study_boundary)
data$study_boundary()
data$study_boundary
lats <- c(64.25086, 64.24937, 63.24105, 63.22868)
lons <- c(-140.9985, -136.9171, -137.0050, -141.0260)
df <- data.frame(lon = lons, lat = lats)
p1 <- df %>%
st_as_sf(coords = c('lon', 'lat'), crs=st_crs(4326)) %>%
summarise(geometry = st_combine(geometry)) %>%
st_cast('POLYGON')
data <- list(
grid = st_read('data/wolverines.gpkg', 'grid5k', quiet = T),
linear = st_read('data/wolverines.gpkg', 'linear_features', quiet = T),
areal = st_read("data/wolverines.gpkg", "areal_features", quiet=T),
factors = st_read("data/wolverines.gpkg", "survey_factors", quiet=T),
# Trondek Hwechin Traditional Territory
thtt = st_read('data/wolverines.gpkg', 'TH_trad_territ', quiet = T),
# And settlement lands
th_settlement = st_read('data/wolverines.gpkg', 'th_settlement_land', quiet = T),
study_boundary = p1
)
data$study_boundary
data$factors
df_unprojected = st_as_sf(df, coords = c('lon', 'lat'), crs = 4326)
df_projected = st_transform(df_unprojected, 3578)
df_projected
data <- list(
grid = st_read('data/wolverines.gpkg', 'grid5k', quiet = T),
linear = st_read('data/wolverines.gpkg', 'linear_features', quiet = T),
areal = st_read("data/wolverines.gpkg", "areal_features", quiet=T),
factors = st_read("data/wolverines.gpkg", "survey_factors", quiet=T),
# Trondek Hwechin Traditional Territory
thtt = st_read('data/wolverines.gpkg', 'TH_trad_territ', quiet = T),
# And settlement lands
th_settlement = st_read('data/wolverines.gpkg', 'th_settlement_land', quiet = T),
study_boundary = df_projected
)
y <- select(x, unlist(input$factors)) %>%
st_intersection(data$study_boundary) %>%
st_drop_geometry()
y
data$factors
input$factors
input <- list(
inv = 'forest_pct',
style = 'quantile',
factors = 'merge_100_pct'
)
x
# duplicate data$factors, replace NAs with 0s
x <- data$factors %>%
mutate(
placer_pct=ifelse(is.na(placer_pct),0,placer_pct),
quartz_pct=ifelse(is.na(quartz_pct),0,quartz_pct),
recent_fires_pct=ifelse(is.na(recent_fires_pct),0,recent_fires_pct),
area500_pct=ifelse(is.na(area500_pct),0,area500_pct),
line500_pct=ifelse(is.na(line500_pct),0,line500_pct),
merge100_pct=ifelse(is.na(merge100_pct),0,merge100_pct),
water_pct=ifelse(is.na(water_pct),0,water_pct),
forest_pct=ifelse(is.na(forest_pct),0,forest_pct),
wetland_pct=ifelse(is.na(wetland_pct),0,wetland_pct)
)
y <- select(x, unlist(input$factors)) %>%
st_intersection(data$study_boundary) %>%
st_drop_geometry()
input <- list(
inv = 'forest_pct',
style = 'quantile',
factors = 'merge100_pct'
)
y <- select(x, unlist(input$factors)) %>%
st_intersection(data$study_boundary) %>%
st_drop_geometry()
y
x
data$study_boundary
plot(data$study_boundary)
df_projected = st_transform(df_unprojected, 3578) %>%
summarise(geometry = st_combine(geometry)) %>%
st_cast('POLYGON')
df_projected
plot(df_projected)
y <- select(x, unlist(input$factors)) %>%
st_intersection(data$study_boundary) %>%
st_drop_geometry()
y
data <- list(
grid = st_read('data/wolverines.gpkg', 'grid5k', quiet = T),
linear = st_read('data/wolverines.gpkg', 'linear_features', quiet = T),
areal = st_read("data/wolverines.gpkg", "areal_features", quiet=T),
factors = st_read("data/wolverines.gpkg", "survey_factors", quiet=T),
# Trondek Hwechin Traditional Territory
thtt = st_read('data/wolverines.gpkg', 'TH_trad_territ', quiet = T),
# And settlement lands
th_settlement = st_read('data/wolverines.gpkg', 'th_settlement_land', quiet = T),
study_boundary = df_projected
)
y <- select(x, unlist(input$factors)) %>%
st_intersection(data$study_boundary) %>%
st_drop_geometry()
y
plot(y)
y <- select(x, unlist(input$factors)) %>%
st_intersection(data$study_boundary) #%>%
plot(y)
lats <- c(63.9, 63.9, 63.4, 63.4)
lons <- c(-139, -137.5, -137.5, -139)
df <- data.frame(lon = lons, lat = lats)
df_unprojected = st_as_sf(df, coords = c('lon', 'lat'), crs = 4326)
df_projected = st_transform(df_unprojected, 3578) %>%
summarise(geometry = st_combine(geometry)) %>%
st_cast('POLYGON')
data <- list(
grid = st_read('data/wolverines.gpkg', 'grid5k', quiet = T),
linear = st_read('data/wolverines.gpkg', 'linear_features', quiet = T),
areal = st_read("data/wolverines.gpkg", "areal_features", quiet=T),
factors = st_read("data/wolverines.gpkg", "survey_factors", quiet=T),
# Trondek Hwechin Traditional Territory
thtt = st_read('data/wolverines.gpkg', 'TH_trad_territ', quiet = T),
# And settlement lands
th_settlement = st_read('data/wolverines.gpkg', 'th_settlement_land', quiet = T),
study_boundary = df_projected
)
y <- select(x, unlist(input$factors)) %>%
st_intersection(data$study_boundary) #%>%
plot(y)
y <- select(x, unlist(input$factors)) %>%
st_intersection(data$study_boundary) #%>%
y
x
?select
# select only factors that user wants to cluster by
# st_drop_geometry() drops geom field from table (geom describes what type of
# feature it is and has some numbers describing it)
print('intersecting study boundary and factors')
y <- select(x, unlist(input$factors), grid_m2) %>%
st_intersection(data$study_boundary) #%>%
y
filter
y
plot(y)
st_drop_geometry()
y <- select(x, unlist(input$factors), grid_m2) %>%
st_intersection(data$study_boundary) %>%
filter(grid_m2 > 24000)
plot(y)
y <- select(x, unlist(input$factors), grid_m2) %>%
st_intersection(data$study_boundary) %>%
filter(grid_m2 > 24000000)
plot(y)
y <- select(x, unlist(input$factors), grid_m2) %>%
st_intersection(data$study_boundary) %>%
filter(grid_m2 > 24000000)
plot(y)
min(y$grid_m2)
y <- select(x, unlist(input$factors), grid_m2) %>%
st_intersection(data$study_boundary)
min(y$grid_m2)
y <- select(x, unlist(input$factors), grid_m2) %>%
st_intersection(data$study_boundary) %>%
filter(grid_m2 > 25000000)
min(y$grid_m2)
plot(y)
y <- select(x, unlist(input$factors), grid_m2) %>%
st_intersection(data$study_boundary) %>%
filter(grid_m2 > 23000000)
plot(y)
y <- select(x, unlist(input$factors), grid_m2) %>%
st_intersection(data$study_boundary) %>%
filter(grid_m2 > 25000000)
source("~/Documents/Code/wolverines/functions.R")
runApp()
shiny::runApp()
source("~/Documents/Code/wolverines/functions.R")
runApp()
study_boundary_init = st_as_sf(df, coords = c('lon', 'lat'), crs = 4326) %>%
st_transform(3578) %>%
summarise(geometry = st_combine(geometry)) %>%
st_cast('POLYGON')
source("~/Documents/Code/wolverines/functions.R")
runApp()
shiny::runApp()
runApp()
shiny::runApp()
lats <- c(63.9, 63.9, 63.4, 63.4)
lons <- c(-139, -137.5, -137.5, -139)
df <- data.frame(lon = lons, lat = lats)
# df_unprojected = st_as_sf(df, coords = c('lon', 'lat'), crs = 4326)
df_projected = st_transform(df_unprojected, 3578) %>%
summarise(geometry = st_combine(geometry)) %>%
st_cast('POLYGON')
df_unprojected = st_as_sf(df, coords = c('lon', 'lat'), crs = 4326) %>%
st_transform(3578) %>%
summarise(geometry = st_combine(geometry)) %>%
st_cast('POLYGON')
input <- list(
inv = 'forest_pct',
style = 'quantile',
factors = 'merge100_pct'
)
data <- reactiveValues(
grid = st_read('data/wolverines.gpkg', 'grid5k', quiet = T),
linear = st_read('data/wolverines.gpkg', 'linear_features', quiet = T),
areal = st_read("data/wolverines.gpkg", "areal_features", quiet=T),
factors = st_read("data/wolverines.gpkg", "survey_factors", quiet=T),
# Trondek Hwechin Traditional Territory
thtt = st_read('data/wolverines.gpkg', 'TH_trad_territ', quiet = T),
# And settlement lands
th_settlement = st_read('data/wolverines.gpkg', 'th_settlement_land', quiet = T),
study_boundary = study_boundary_init,
clicklist = list()
)
data <- list(
grid = st_read('data/wolverines.gpkg', 'grid5k', quiet = T),
linear = st_read('data/wolverines.gpkg', 'linear_features', quiet = T),
areal = st_read("data/wolverines.gpkg", "areal_features", quiet=T),
factors = st_read("data/wolverines.gpkg", "survey_factors", quiet=T),
# Trondek Hwechin Traditional Territory
thtt = st_read('data/wolverines.gpkg', 'TH_trad_territ', quiet = T),
# And settlement lands
th_settlement = st_read('data/wolverines.gpkg', 'th_settlement_land', quiet = T),
study_boundary = df_projected
)
data <- list(
grid = st_read('data/wolverines.gpkg', 'grid5k', quiet = T),
linear = st_read('data/wolverines.gpkg', 'linear_features', quiet = T),
areal = st_read("data/wolverines.gpkg", "areal_features", quiet=T),
factors = st_read("data/wolverines.gpkg", "survey_factors", quiet=T),
# Trondek Hwechin Traditional Territory
thtt = st_read('data/wolverines.gpkg', 'TH_trad_territ', quiet = T),
# And settlement lands
th_settlement = st_read('data/wolverines.gpkg', 'th_settlement_land', quiet = T),
study_boundary = study_boundary_init
)
study_boundary_init = st_as_sf(df, coords = c('lon', 'lat'), crs = 4326) %>%
st_transform(3578) %>%
summarise(geometry = st_combine(geometry)) %>%
st_cast('POLYGON')
data <- list(
grid = st_read('data/wolverines.gpkg', 'grid5k', quiet = T),
linear = st_read('data/wolverines.gpkg', 'linear_features', quiet = T),
areal = st_read("data/wolverines.gpkg", "areal_features", quiet=T),
factors = st_read("data/wolverines.gpkg", "survey_factors", quiet=T),
# Trondek Hwechin Traditional Territory
thtt = st_read('data/wolverines.gpkg', 'TH_trad_territ', quiet = T),
# And settlement lands
th_settlement = st_read('data/wolverines.gpkg', 'th_settlement_land', quiet = T),
study_boundary = study_boundary_init
)
# duplicate data$factors, replace NAs with 0s
x <- data$factors %>%
mutate(
placer_pct=ifelse(is.na(placer_pct),0,placer_pct),
quartz_pct=ifelse(is.na(quartz_pct),0,quartz_pct),
recent_fires_pct=ifelse(is.na(recent_fires_pct),0,recent_fires_pct),
area500_pct=ifelse(is.na(area500_pct),0,area500_pct),
line500_pct=ifelse(is.na(line500_pct),0,line500_pct),
merge100_pct=ifelse(is.na(merge100_pct),0,merge100_pct),
water_pct=ifelse(is.na(water_pct),0,water_pct),
forest_pct=ifelse(is.na(forest_pct),0,forest_pct),
wetland_pct=ifelse(is.na(wetland_pct),0,wetland_pct)
)
# select only factors that user wants to cluster by
# st_drop_geometry() drops geom field from table (geom describes what type of
# feature it is and has some numbers describing it)
# print('intersecting study boundary and factors')
y <- select(x, unlist(input$factors), grid_m2) %>%
st_intersection(data$study_boundary) %>%
filter(grid_m2 > 25000000)
# Now actually cluster cells
# kmeans() returns a list; $cluster object is a vector where the name is the
# cell number and the value is what cluster it's in
clust <- kmeans(scale(y), input$clusters)$cluster
input$cluster
input <- list(
inv = 'forest_pct',
style = 'quantile',
factors = 'merge100_pct',
clusters = 4
)
# Now actually cluster cells
# kmeans() returns a list; $cluster object is a vector where the name is the
# cell number and the value is what cluster it's in
clust <- kmeans(scale(y), input$clusters)$cluster
# select only factors that user wants to cluster by
# st_drop_geometry() drops geom field from table (geom describes what type of
# feature it is and has some numbers describing it)
# print('intersecting study boundary and factors')
y <- st_intersection(data$study_boundary) %>%
filter(grid_m2 > 25000000) %>%
select(x, unlist(input$factors), grid_m2) %>%
st_drop_geometry()
y <- st_intersection(data$study_boundary)
y
y <- select(x, unlist(input$factors), grid_m2) %>%
st_intersection(data$study_boundary)
y
# select only factors that user wants to cluster by
# st_drop_geometry() drops geom field from table (geom describes what type of
# feature it is and has some numbers describing it)
# print('intersecting study boundary and factors')
y <- select(x, unlist(input$factors), grid_m2) %>%
st_intersection(data$study_boundary) %>%
filter(grid_m2 > 25000000) %>%
select(unlist(input$factors))
y
# Now actually cluster cells
# kmeans() returns a list; $cluster object is a vector where the name is the
# cell number and the value is what cluster it's in
clust <- kmeans(scale(y), input$clusters)$cluster
scale(y)
y
# select only factors that user wants to cluster by
# st_drop_geometry() drops geom field from table (geom describes what type of
# feature it is and has some numbers describing it)
# print('intersecting study boundary and factors')
y <- select(x, unlist(input$factors), grid_m2) %>%
st_intersection(data$study_boundary) %>%
filter(grid_m2 > 25000000) %>%
select(unlist(input$factors)) %>%
st_drop_geometry()
y
# Now actually cluster cells
# kmeans() returns a list; $cluster object is a vector where the name is the
# cell number and the value is what cluster it's in
clust <- kmeans(scale(y), input$clusters)$cluster
source("~/Documents/Code/wolverines/functions.R")
runApp()
shiny::runApp()
lats <- c(63.9, 63.9, 63.4, 63.4)
lons <- c(-139, -137.5, -137.5, -139)
df <- data.frame(lon = lons, lat = lats)
study_boundary_init = st_as_sf(df, coords = c('lon', 'lat'), crs = 4326) %>%
st_transform(3578) %>%
summarise(geometry = st_combine(geometry)) %>%
st_cast('POLYGON')
data <- list(
grid = st_read('data/wolverines.gpkg', 'grid5k', quiet = T),
linear = st_read('data/wolverines.gpkg', 'linear_features', quiet = T),
areal = st_read("data/wolverines.gpkg", "areal_features", quiet=T),
factors = st_read("data/wolverines.gpkg", "survey_factors", quiet=T),
# Trondek Hwechin Traditional Territory
thtt = st_read('data/wolverines.gpkg', 'TH_trad_territ', quiet = T),
# And settlement lands
th_settlement = st_read('data/wolverines.gpkg', 'th_settlement_land', quiet = T),
study_boundary = study_boundary_init
)
input <- list(
inv = 'forest_pct',
style = 'quantile',
factors = 'merge100_pct',
clusters = 4
)
pal = 'YlGn'
# duplicate data$factors, replace NAs with 0s
x <- data$factors %>%
mutate(
placer_pct=ifelse(is.na(placer_pct),0,placer_pct),
quartz_pct=ifelse(is.na(quartz_pct),0,quartz_pct),
recent_fires_pct=ifelse(is.na(recent_fires_pct),0,recent_fires_pct),
area500_pct=ifelse(is.na(area500_pct),0,area500_pct),
line500_pct=ifelse(is.na(line500_pct),0,line500_pct),
merge100_pct=ifelse(is.na(merge100_pct),0,merge100_pct),
water_pct=ifelse(is.na(water_pct),0,water_pct),
forest_pct=ifelse(is.na(forest_pct),0,forest_pct),
wetland_pct=ifelse(is.na(wetland_pct),0,wetland_pct)
)
x
# select only factors that user wants to cluster by
# st_drop_geometry() drops geom field from table (geom describes what type of
# feature it is and has some numbers describing it)
# print('intersecting study boundary and factors')
y <- select(x, unlist(input$factors), grid_m2) %>%
st_intersection(data$study_boundary) %>%
filter(grid_m2 > 25000000) %>%
select(unlist(input$factors)) %>%
st_drop_geometry()
# Now actually cluster cells
# kmeans() returns a list; $cluster object is a vector where the name is the
# cell number and the value is what cluster it's in
clust <- kmeans(scale(y), input$clusters)$cluster
# add field to x with what cluster the cell is in
x <- x %>%
mutate(clusters = clust)
x
x
y
# select only factors that user wants to cluster by
# st_drop_geometry() drops geom field from table (geom describes what type of
# feature it is and has some numbers describing it)
# print('intersecting study boundary and factors')
y <- select(x, unlist(input$factors), id, grid_m2) %>%
st_intersection(data$study_boundary) %>%
filter(grid_m2 > 25000000) %>%
st_drop_geometry()
y
# Now actually cluster cells
# kmeans() returns a list; $cluster object is a vector where the name is the
# cell number and the value is what cluster it's in
clust <- kmeans(scale(y$merge100_pct), input$clusters)$cluster
clust
x
# add field to x with what cluster the cell is in
x <- x %>%
filter(id %in% y$id) %>%
mutate(clusters = clust)
x
# add field to x with what cluster the cell is in
x <- x %>%
filter(id %in% y$id) %>%
mutate(clusters = clust)
# print(x)
# print(class(x))
data$clusters <- x
source("~/Documents/Code/wolverines/functions.R")
runApp()
shiny::runApp()
lats <- c(63.9, 63.9, 63.4, 63.4)
lons <- c(-139, -137.5, -137.5, -139)
df <- data.frame(lon = lons, lat = lats)
study_boundary_init = st_as_sf(df, coords = c('lon', 'lat'), crs = 4326) %>%
st_transform(3578) %>%
summarise(geometry = st_combine(geometry)) %>%
st_cast('POLYGON')
data <- list(
grid = st_read('data/wolverines.gpkg', 'grid5k', quiet = T),
linear = st_read('data/wolverines.gpkg', 'linear_features', quiet = T),
areal = st_read("data/wolverines.gpkg", "areal_features", quiet=T),
factors = st_read("data/wolverines.gpkg", "survey_factors", quiet=T),
# Trondek Hwechin Traditional Territory
thtt = st_read('data/wolverines.gpkg', 'TH_trad_territ', quiet = T),
# And settlement lands
th_settlement = st_read('data/wolverines.gpkg', 'th_settlement_land', quiet = T),
study_boundary = study_boundary_init
)
input <- list(
inv = 'forest_pct',
style = 'quantile',
factors = 'merge100_pct',
clusters = 4
)
# duplicate data$factors, replace NAs with 0s
x <- data$factors %>%
mutate(
placer_pct=ifelse(is.na(placer_pct),0,placer_pct),
quartz_pct=ifelse(is.na(quartz_pct),0,quartz_pct),
recent_fires_pct=ifelse(is.na(recent_fires_pct),0,recent_fires_pct),
area500_pct=ifelse(is.na(area500_pct),0,area500_pct),
line500_pct=ifelse(is.na(line500_pct),0,line500_pct),
merge100_pct=ifelse(is.na(merge100_pct),0,merge100_pct),
water_pct=ifelse(is.na(water_pct),0,water_pct),
forest_pct=ifelse(is.na(forest_pct),0,forest_pct),
wetland_pct=ifelse(is.na(wetland_pct),0,wetland_pct)
)
# select only factors that user wants to cluster by
# st_drop_geometry() drops geom field from table (geom describes what type of
# feature it is and has some numbers describing it)
# print('intersecting study boundary and factors')
y <- select(x, unlist(input$factors), id, grid_m2) %>%
st_intersection(data$study_boundary) %>%
filter(grid_m2 > 25000000) %>%
st_drop_geometry()
# Now actually cluster cells
# kmeans() returns a list; $cluster object is a vector where the name is the
# cell number and the value is what cluster it's in
clust <- kmeans(scale(y$merge100_pct), input$clusters)$cluster
# add field to x with what cluster the cell is in
x <- x %>%
filter(id %in% y$id) %>%
mutate(clusters = clust)
# print(x)
# print(class(x))
data$clusters <- x
plot(data$clusters)
# select only factors that user wants to cluster by
# st_drop_geometry() drops geom field from table (geom describes what type of
# feature it is and has some numbers describing it)
# print('intersecting study boundary and factors')
y <- select(x, unlist(input$factors), id, grid_m2) %>%
st_intersection(data$study_boundary) %>%
filter(grid_m2 > 23000000) %>%
st_drop_geometry()
# Now actually cluster cells
# kmeans() returns a list; $cluster object is a vector where the name is the
# cell number and the value is what cluster it's in
clust <- kmeans(scale(y$merge100_pct), input$clusters)$cluster
# add field to x with what cluster the cell is in
x <- x %>%
filter(id %in% y$id) %>%
mutate(clusters = clust)
plot(x)
# Now actually cluster cells
# kmeans() returns a list; $cluster object is a vector where the name is the
# cell number and the value is what cluster it's in
clust <- kmeans(scale(y$merge100_pct), input$clusters)$cluster
plot(x$clusters)
tm_shape(data$clusters) + tm_fill('clusters', palette = 'Set1',
alpha = 1,
group = 'Clusters',
# zindex determines the order that elements
# appear on the page; an element with a
# higher z index appears in front of a lower
# zindex
zindex = 500)
source("~/Documents/Code/wolverines/functions.R")
runApp()
runApp()
runApp()
shiny::runApp()
source("~/Documents/Code/wolverines/functions.R")
runApp()
